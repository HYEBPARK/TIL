[JAVA OOP 03/22](https://velog.io/@hye_b/TIL-JAVA-OOP-%EC%9D%B4%EC%95%BC%EA%B8%B0)

# 👨‍👩‍👧‍👦 OOP(Object Oriented Programming)

## 1. 객체지향 프로그래밍 
- 프로그램을 객체로 구성하는 것
- 프로그램이 거대화하면서 등장하게 되었음
=> 일을 잘게 쪼개서 객체에게 위임하고, 서로 협력하게 만드는 것
- 객체는 TYPE으로 구분한다.

- **프로그래밍에서 단위를 명령어들의 집합이 아닌 객체들의 집합과 객체들 간의 연관관계를 바탕으로 설계하는 프로그래밍 방식**

## 2. 객체지향의 특성
### (1) 캡슐화
- 완성도가 있다.
	- 기능을 수행하는 단위로써 완전함을 갖는다.
- 정보가 은닉되어 있다.
	- 객체의 정보가 밖으로 전달되거나, 밖에서 객체 내의 정보에 접근하지 못한다. 
=> 객체 스스로 동작가능한 환경을 가져야하고, 외부에 의존하거나, 외부 침략을 제한해야한다.
- **코드를 재수정 없이 재활용하고 접근 제어자를 통해 정보를 은닉한다.**
#### 접근 제어자
- private : 해당 클래스에서만 접근 가능
- protected : 동일 패키지의 클래스와 상속된 객체가 접근 가능
- default : 동일 패키지 내에서 접근 가능 
- public : 모두 접근 가능
### (2) 상속
- 상위 객체, 부모, super, 추상객체
- 하위 객체, 자식, (this), 구체객체
- **부모 클래스의 속성과 기능을 그대로 이어받아 사용할 수 있고, 자식클래스에서 재정의할 수 있다. 다중 상속은 불가능 하다** 
### (3) 추상화
- 추상화된 객체 : 추상체
- 구체적인 객체 : 구상체
- 객체간의 관계에서 상위에 있는 것이 항상 하위보다 추상적이다. 
- **공통의 속성이나 기능을 묶어 이름을 붙이는 것**
- **강아지, 고양이, 햄스터를 객체라 하고 이를 묶을때 동물 또는 생물이라고 묶을 수 있다.**
### (4) 다형성
- 객체가 여러가지 타입을 가진다. 
- **하나의 속성이나 행위가 상황에 따라 다른 의미로 해석될 수 있다.
- **overriding : 부모 클래스에 이미 정의된 메소드를 자식 클래스에서 같은 이름을 갖는 메소드로 재정의하는 것으로 선언부가 같아야한다**
- **overloading : 같은 이름인 메소드를 새로운 메소드르 정의하는 것**
## 3. 객체지향 설계
- 객체지향 프로그래밍 : 기능을 객체에게 나눠서 수행시킴 
=> 객체를 어떻게 구분했다. 
=> 객체간의 연관관계가 어떠하다.
- 설명하기 위한 도구 : UML
	- Usecase Diagram
 	- Sequence Diagram	
 	- Package Diagram
 	- Class Diagram

### 📃 객체지향 설계를 하는 5가지 원칙
- **Single Responsibility Principle** : 단일 책임 원칙
   => 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. 
- **Open Closed Priciple** : 개방 폐쇄 원칙 
=> sw entity(class, method ...)는 확장에는 열려있고 변경에는 닫혀있어야한다.
- **Listov Substitution Priciple** : 리스코프 치환 원칙 
=> 추상객체로 사용되는 부분에 구상객체가 들어가도 문제 없어야함
=> 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
=> 하위 분류는 상위 분류의 한 종류이다.
=> 구현 분류는 인터페이스 할 수 있어야 한다.
- **Interface Segregation Principle** : 인터페이스 분리 원칙
=> 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다. 
=> SRP와 같은 문제에대한 다른 해결책으로 보통 SRP를 적용하는 것이 더 좋은 해결책이다.
=> 인터페이스 분리 법칙
- **Dependency Inversion Priciple** : 의존 역전 원칙
=> 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다. 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야한다. 자주 변경되는 구체클래스에 의존하지 마라.

    
